##JAVA

#####1.equals与==的区别，equals测试的是两个对象是否相等方法clone进行对象拷贝方法，与 equal 有什么区别同样用于鉴定2个对象是否相等的

基本数据类型比较用==，比较的是值

复合数据类型（类），用==时比较的是在内存中的存放地址，未覆写equals方法前，equals与==一样比较的是在内存中的存放地址。

clone方法执行的是浅拷贝，需覆写Object中的clone方法，实现深拷贝，该类内部的符合数据结构都需实现Cloneable接口

#####2.Object有哪些公用方法？

Clone、toString、equals、getClass、hashCode、notify、notifyAll、wait、finalize

##### 3. Java的四种引用，强弱软虚，各自的应用场景

强引用不会被GC回收,垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

软引用：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。软引用可用来实现内存敏感的高速缓存。

弱引用：在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。Weak引用对象常常用于Map数据结构中，引用占用内存空间较大的对象

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

#####4. String、StringBuffer与StringBuilder的区别

String不可变，StringBuffer和StrgingBuilder可变

String和StringBuffer线程安全,StringBuilder线程不安全

StringBuffer和StrringBuilder拥有共同 父类AbstractStringBuilder(**抽象类**)

如果要操作少量的数据用 = String

单线程操作字符串缓冲区 下操作大量数据 =StringBuilder 

多线程操作字符串缓冲区下操作大量数据 = StringBuffer

简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。
 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。

#####5. Override和Overload的含义与区别

Override重写，父类与子类之间多态性的一种表现

Overload重载，一个类多态性的一种表现(同名函数，参数不同)

#####6. 抽象类和接口的区别

语法层面：

1、 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法

2、  抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

3、  接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

4、  一个类只能继承一个抽象类，而一个类却可以实现多个接口。

设计层面：

1、抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象

2、设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。

#####7.JAVA多态的实现原理

 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

Java实现多态有三个必要条件：继承、重写、向上转型。

继承：在多态中必须存在有继承关系的子类和父类。

重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。

向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。

对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。

多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。

#####8. Final 能修饰什么

用final修饰的类不能被继承，即不能拥有自己的子类。

final修饰的方法不能被重写，但可以被重载。若父类中final修饰的方法为private，将会导致子类中不能直接继承到此方法，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。

final修饰的变量都是首次显示初始化后值都不能修改。引用变量指向的是实际的对象，但其存储的是所指向对象的地址，其值不能修改并不意味着其所指向的对象不能修改。

#####9.String 类可以被继承吗？为什么？ 

String被final修饰，不能被继承

#####10. 九种基本数据类型的大小，以及他们的封装类 

int, long, float, double, short, byte, char,boolean, void

Integer, Long, Float, Double, Short, Byte, Character, Boolean, Void

4, 8, 4, 8, 2, 1, 英文1中文2, 1

#####11. Java面向对象的三个特征与含义

继承、封装、多态

**继承**：类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

**封装**：一种将抽象性函数接口的实现细节部份包装、隐藏起来的方法。要访问该类的代码和数据，必须通过严格的接口控制。

**多态**：多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作

#####12. Static class 与non static class的区别

内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面

#####13. foreach与正常for循环效率对比

在固定长度或长度不需要计算的时候for循环效率高于foreach.

在不确定长度,或计算长度有性能损耗的时候,用foreach比较方便.

#####14. java同步方法

​     同步方法 

​     同步代码块

​     使用特殊域变量(volatile)实现线程同步

​     使用重入锁实现线程同步

​     使用局部变量实现线程同步

#####15.volatile关键字的含义

编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。

当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。

而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步

1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

2）它会强制将对缓存的修改操作立即写入主存；

3）如果是写操作，它会导致其他CPU中对应的缓存行无效。

#####16. final finally finalize的区别

final

修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重重写。 

finally

异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。一般异常处理块需要。

finalize

方法名。Java 技术允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 

Java中所有类都从Object类中继承finalize()方法。

当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。

那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java NativeInterface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。

#####17. ry catch finally，try里有return，finally还执行么？

1、不管有木有出现异常，finally块中代码都会执行；

2、当try和catch中有return时，finally仍然会执行；

3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；

4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。

#####18. Exception 与 Error 的区别,包结构

Error类和Exception类的父类都是throwable类，他们的区别是：

Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。

Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

#####19. throw和throws 

throw是语句抛出一个异常。

语法：throw (异常对象);

​         throw e;

throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)

语法：[(修饰符)](返回值类型)(方法名)([参数列表])[throws(异常类)]{......}

​           public void doA(int a) throws Exception1,Exception3{......}

#####20. JAVA中堆和栈的区别，说下java 的内存机制

在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。

当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

堆内存用来存放由new创建的对象和数组。

在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。

在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。

引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。

Java 把内存划分成两种：一种是栈内存，另一种是堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。

　　堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。

　　这也是 Java 比较占内存的原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针！作者：justin_pan链接：https://www.jianshu.com/p/db26fa2b7aa3來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### 21.runtime exception和非runtime exception 

 ① RuntimeException：RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等。处理RuntimeException的原则是：如果出现RuntimeException，那么一定是程序员的错误。例如，可以通过检查数组下标和数组边界来避免数组越界访问异常。 
②其他非RuntimeException（IOException等等）：这类异常一般是外部错误，例如试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。

#####22. ArrayList、LinkedList、Vector的区别。

LinkedList类

　　LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。

　　注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：

　　　　List list = Collections.synchronizedList(new LinkedList(...));

ArrayList类

　　ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。

size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。

　　每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。

　　和LinkedList一样，ArrayList也是非同步的（unsynchronized）。

Vector类

　　Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。

#####23. JAVA和C++

1.面向对象思想，对于java而言，每一个操作都是由对象来执行完成的。即所有的操作执行都是由对象这个发起的。而C++则不同，除了以面向对象作为完全的主体之外，还保留了一些较为灵活的设置，可以采用非面向对象的方式执行，这大概是由于它兼容C语言才有的特殊性质吧。

​    2.内存管理机制，Java的内存管理是java语言自身进行管理的，它依靠的是一个线程优先级很低的一个线程对内存进行监控，当有内存长时间处于未使用，则对其进行回收。而这一点，C++把这些留给了程序员自己。这个虽然看起来是一个极大的灵活度，却也是导致了C++特别难学的一个关键因素。

   3.第三方库支持，由于java程序员的人数在过去的几年中暴烈增长，导致市场上对于java的一些库市场也十分丰富。这一点，C++则显的要寒酸一些了，由于C++的库主要都是一些底层的应用的API库，而底层设计和开发的需求相对于应用而言，要少很多。所以C++的库支持相对要少一些。

   4.对程序员的灵活度，这个java是没有的，由于java主要用作应用层开发，其本身的封装性，让程序员在酣畅淋漓的编程中也无法了解到底层的一些实现机制。同时，程序员无法直接去操作编译器，连接器等等。相比较而言，C++则是方便的多，它甚至可以修改函数执行的入口，函数定义的时间以及其他更为复杂和灵活的操作。

   5.执行效率，不得不说，这个可能是争论最多的一个地方了。首先，何为效率？是指代码运行的速度？还是指我们总得人力成本时间占比？单纯从一两行代码中，我们当然会说C++效率远胜java。但是，有没有考虑投入的人力成本和后期的维护成本.由于C++的高深艰涩，其维护成本更是与工程师的水平相关极大，这个成本算起来的话。或许，就不能轻易下结论了。

#####23. finalize一般在什么时候用，回收时一定能被运行

垃圾回收器准备释放内存的时候，会先调用finalize()。

​       (1).对象不一定会被回收。

​       (2).垃圾回收不是析构函数。

​       (3).垃圾回收只与内存有关。

​       (4).垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。

​	第0代已满  第0代满时，垃圾回收会自动开始。改时间是目前导致Finalize方法被调用的最常见的一种方式，因为随着应用程序代码运行并分配新对象，这个时间会自然而然发生。

　　代码显式调用System.GC的静态方法Collect   代码显式的请求CLR执行垃圾回收。显然Microsoft强烈建议不要这么做，但某些时候还是必要的。

　　Windows报告内存不足   CLR内部使用Win32 CreateMemoryResourceNotification和QueryMemoryResourceNotification函数来监视系统的总体内存。如果Windows报告内存不足，CLR就强制执行垃圾回收，尝试释放已经死亡的对象，从而减小进程工作集的大小。

　　CLR卸载AppDomain  一个AppDomain被卸载时，CLR认为AppDomain中不再存在任何根，因此会对所有代的对象执行垃圾回收。

　　CLR关闭  一个进程正常终止时，CLR就会关闭。在关闭过程中，CLR会认为该进程不存在任何根，因此会调用托管堆中所用对象的Finalize方法。注意，CLR此时不会尝试压缩或释放内存，因为整个进程要终止，将由Windows负责回收进程的所有内存。 

　　CLR使用一个特殊的、专用的线程来调用Finalize方法。对于前4种事情，如果一个Finalize方法进入了无限循环，这个特殊的线程就会被阻塞，其他Finalize方法就得不到调用。这种请狂况非常糟糕。因为应用程序永远都不会回收由可终结的对象占据的内存------只要应用程序运行，就会一直泄露内存。

#####24. Android 下的 IPC 几种通信方式


1.bundle ：
简单易用  但是只能传输Bundle支持的对象 常用于四大组件间进程间通信 
2.文件共享：
简单易用  但不适合在高并发的情况下 并且读取文件需要时间 不能即时通信   常用于并发程度不高 并且实时性要求不高的情况
3.AIDL ：
功能强大 支持一对多并发通信 支持即时通信   但是使用起来比其他的复杂 需要处理好多线程的同步问题  常用于一对多通信 且有RPC 需求的场合(服务端和客户端通信)
4.Messenger ：
功能一般 支持一对多串行通信 支持实时通信  但是不能很好处理高并发情况 只能传输Bundle支持的类型  常用于低并发的无RPC需求一对多的场合 
5.ContentProvider ：
在数据源访问方面功能强大 支持一对多并发操作 可扩展call方法  可以理解为约束版的AIDL  提供CRUD操作和自定义函数  常用于一对多的数据共享场合
6.Socket ：
功能强大 可以通过网络传输字节流 支持一对多并发操作  但是实现起来比较麻烦 不支持直接的RPC   常用于网络数据交换

总结起来  
当仅仅是跨进程的四大组件间的传递数据时 使用Bundle就可以  简单方便  
当要共享一个应用程序的内部数据的时候  使用ContentProvider实现比较方便  
当并发程度不高  也就是偶尔访问一次那种 进程间通信 用Messenger就可以  
当设计网络数据的共享时  使用socket 
当需求比较复杂  高并发 并且还要求实时通信 而且有RPC需求时  就得使用AIDL了 
文件共享的方法用于一些缓存共享 之类的功能

##### 25. 面向对象和面向过程

```
面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 

面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用分别的函数来实现，问题就解决了。

而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为 1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的i变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。

可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。

功能上的统一保证了面向对象设计的可扩展性。比如我要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。
```

##### 26. const、define区别

角度1： 
就定义常量说的话： 
const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。

角度2： 
就起作用的阶段而言： 
define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。

角度3： 
就起作用的方式而言： 
define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 

正因为define只是简单的字符串替换会导致边界效应

从代码调试的方便程度而言： 
const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了

角度6： 
从是否可以再定义的角度而言： 
const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。

角度7： 
从某些特殊功能而言： 
define可以用来防止头文件重复引用，而const不能

#####27.new、malloc区别

0.       属性

new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。

1.       参数

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

2.       返回类型

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

3.       分配失败

new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。

4.      自定义类型

​         new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

​         malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

5.      重载

C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。

6.       内存区域

new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

##### 28. java的反射机制

Java反射机制可以让我们在运行时加载，探知，使用编译期间完全未知的classes。换句话说就是Java程序可以加载一个在运行时才得知名称的class，获悉其完整构造，并生成其对象实体，或对其fields设值，或调用其methods。 
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

##### 19.C++传参 

传递引用与传指针、传值的区别？

(1)传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象(在主调函数中)的操作。

(2)使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作;而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本;如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

(3)使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的解指针操作进行运算，这很容易产生错误且程序的阅读性较差;另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

#####20. 一致哈希

##### 21. 开链法

当发生冲突时，该位置上的数据会用链表链起来，当表中的某些位置没有结点时，该位置就为NULL！！这种方法在实现时就需要多加一个next指针，使这些结点才能链起来。

##### 22. 数据库索引的数据结构

B+树

##### 23. Switch能否用string做参数？

Java7以后可以

## C++

##### 1. C++中const的使用(详解看网站和笔记)

非常量引用不能指向一个常量引用

一般放在函数体后，形如：void fun() const;

​       如果一个成员函数的不会修改数据成员，那么最好将其声明为const，因为const成员函数中不允许对数据成员进行修改，如果修改，编译器将报错，这大大提高了程序的健壮性。

一般放在函数体后，形如：void fun0(const A* a );const A fun2( );

总结] 一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。

##### 2. 多态的实现

C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数

  1：用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。  

  2：存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  

  3：多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。  

  4：多态用虚函数来实现，结合动态绑定.  

  5:   纯虚函数是虚函数再加上 = 0；  

  6：抽象类是指包括至少一个纯虚函数的类。

纯虚函数:virtual void fun()=0;即抽象类！必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。

##### 3. 虚函数指针与虚函数表分别什么时候生成

表格中的virtual functions地址是如何被建构起来的？在C++中，virtual functions（可经由其class object被调用）可以在编译时期获知。此外，这一组地址是固定不变的，执行期不可能新增或替换之。由于程序执行时，表格的大小和内容都不会改变，所以其建构和存取皆可以由编译器完全掌控，不需要执行期的任何介入。

##### 4. 类A有3个函数，类B继承A并重写其中一个函数（虚函数），画出A,B的内存分布

![img](https://images2015.cnblogs.com/blog/793131/201609/793131-20160907194640644-244579821.jpg)

##### 5. 空类的size是多少，为什么

1字节。

为每一个X实例分配1字节空间，这样就可以让不同的X实例地址不同了，以此区分不同的X实例。如果大小为0，那么很多个X实例放在一起的时候他们的地址是相同的，无法分辨。随便反对一下大小为0就没有地址的说法。申请大小为0的内存空间是没有问题的，也会被分配一个地址。

```
X* myarray = new X[N];
for(X* i = &myarray[0]; i != &myarray[N]; ++i){
    ...
}
```

而如果元素大小为0，那么myarray[0]和myarray[N]地址就相等了，这个循环直接就进不去了。

**但是，有两种情况值得我们注意**

第一种情况，涉及到空类的继承。 
当派生类继承空类后，派生类如果有自己的数据成员，而空基类的一个字节并不会加到派生类中去。例如

```
class Empty {};
struct D : public Empty { int a;};
```

**sizeof(D)为4。**

第二中情况，一个类包含一个空类对象数据成员。

```
class Empty {};
class HoldsAnInt {
    int x;
    Empty e;
}；
```

**sizeof(HoldsAnInt)为8。** 
因为在这种情况下，空类的1字节是会被计算进去的。而又由于字节对齐的原则，所以结果为4+4=8。

继承空类的派生类，如果派生类也为空类，大小也都为1。 

##### 6. class A ｛virtual F();int a;char b;};的size是多少，为什么。如果机器是64位的size又是多少。（看网站）

- 首先，类大小的计算遵循结构体的对齐原则
- 类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响（静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类所有的对象所共享，并不属于具体哪个对象，静态数据成员定义在内存的全局区。）
- 虚函数对类的大小有影响，是因为虚函数表指针带来的影响
- 虚继承对类的大小有影响，是因为虚基表指针带来的影响
- 空类的大小是一个特殊情况,空类的大小为1

虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符”\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在vs下，这个值是NULL。而在linux下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 
因为对象b中多了一个指向虚函数表的指针，而指针的sizeof是8，因此含有虚函数的类或实例最后的sizeof是实际的数据成员的sizeof加8。

##### 7. 成员函数的调用

从上图可以看出，成员函数最终被编译成与对象无关的普通函数，如果函数体中没有成员变量，那问题就很简单，不用对函数做任何处理，直接调用即可。

如果成员函数中使用到了成员变量，该怎么办呢？成员变量的作用域不是全局，不经任何处理就无法在函数内部访问。

C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。

**函数调用原理**

　　以前都理解错了啊，其实函数调用原理和->运算符和.运算符并没由任何关系

　　函数调用其实是有两种：**动态绑定**和**静态绑定**

　　前者相信很多人面试的时候都被问到过！然而我以前只知道个皮毛！！！！

　**所谓动态绑定**就是一个类的指针或者引用在调用一个虚函数的时候，并不直接指向该函数的地址，而是指向这个类的虚函数表，比如

　　A& a;

　　a->func();//假设func()是类A的虚函数

　　这里的调用关系实质是A::this->vfptr;//编译阶段就调到这里，到运行时，就vfptr->func()

　　这就是所谓的动态绑定

　　**而静态绑定就是**

　　A a;

　　a.func();//假设func是个虚函数

　　这里的调用关系就是直接指向func()函数的地址，不通过A::this->vfptr,而是直接指向func()的地址

　　另外：这个例子中a.func()调用的是A类中的虚函数(假设已重写)，而不是父类中的虚函数，

**总结：**

**假设用得是.运算符，则肯定是静态绑定，不管是不是虚函数**

**假设用得是->运算符，且调用函数是虚函数，则肯定是动态绑定，若不是虚函数，肯定不是动态绑定**

##### 8. stl vector的特点，内存是怎么增长的，手写vector push_back的实现（重点是内存迁移）

**vector内存增长**

vector所有的内存相关问题都可以归结于它的内存增长策略。vector有一个特点就是：内存空间只会增长不会减少。vector有两个函数，一个是**capacity()**，返回对象缓冲区（vector维护的内存空间）实际申请的空间大小，另一个**size()**，返回当前对象缓冲区存储数据的个数。对于vector来说，capacity是永远大于等于size的，档capacity和size相等时，vector就会扩容，**capacity**变大。

比如说vector最常用的**push_back**操作，它的整个过程是怎么一个机制呢？这个问题经常在面试中出现。

这个问题其实很简单，在调用**push_back**时，若当前容量已经不能够放入心得元素（capacity=size），那么vector会重新申请一块内存，把之前的内存里的元素拷贝到新的内存当中，然后把push_back的元素拷贝到新的内存中，最后要析构原有的vector并释放原有的内存。所以说这个过程的效率是极低的，为了避免频繁的分配内存，C++每次申请内存都会成倍的增长，例如之前是4，那么重新申请后就是8，以此类推。当然不一定是成倍增长，比如在我的编译器环境下实测是0.5倍增长，之前是4，重新申请后就是6。

**内存释放**

就像前面所说的，vector的内存空间是只增加不减少的，我们常用的操作clear()和erase()，实际上只是减少了size()，清除了数据，并不会减少capacity，所以内存空间没有减少。那么如何释放内存空间呢，正确的做法是swap()操作。

也可以简单使用以下操作

```
vector<Point>().swap(pointVec); //或者pointVec.swap(vector<Point> ())  
```

swap交换技巧实现内存释放思想：vector()使用vector的默认构造函数建立临时vector对象，再在该临时对象上调用swap成员，swap调用之后原来vector占用的空间就等于一个默认构造的对象的大小，临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。交换之后，temp会被析构。

##### 9. 虚函数使用规则

**virtual在函数中的使用限制**

- **普通函数不能是虚函数，也就是说这个函数必须是某一个类的成员函数，不可以是一个全局函数，否则会导致编译错误。**
- **静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。**
- **内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。**
- **构造函数不能是虚函数，否则会出现编译错误。**

##### 10. 代码和问题

```
class a 
{ 
  virtual void f() { 
     Cout << "a"; 
  } 
} 
class b：public a { 
  void f() { cout << 'b'; } 
} 
```

  1）这个程序能编译通过吗？为什么

​	不可以，因为虚函数被定义为私有变量

  2）如果只能加一个访问控制，在哪里加？为什么

​	在a的虚函数前面加public，派生类就可以继承子类，输出的结果为b

注意：

```
class Base  
{  
public:  
    virtual void f(int i=0) {cout << "f() in Base..." << i << endl;}  
};  
class Derived:public Base  
{  
private:  
    void f(int i=1){cout << "f() in derived..." << i << endl;}  
};  
  
int main(void)  
{  
    Base *b = new Derived();  
    b->f();  
    return 0;  
}  
```

上述代码的输出为： f() in derived 0

首先分析，为什么输出结果是f() in derived.  编译器在看到b对f进行调用时，此时编译器根据b的静态类型（也就是Base）来决定f函数是否可访问，由于f函数式public的，OK， "访问控制为public"并没有影响调用，**并且进行形参的默认参数的赋值。**

由于f是虚函数，那么具体调用哪个函数是在运行时确定的，于是，在运行时查找Derived的虚函数表，得到虚函数f（此时的f已经被Derived类覆盖，于是调用的就是派生类的版本。）

在C++代码中，函数的参数值是静态绑定的，而通过基类的指针或者引用对virtual函数调用的动态绑定的，绝不重新定义继承而来的函数的缺省参数值

##### 11. 智能指针

对于编译器来说，智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator->”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。

访问智能指针包含的裸指针则可以用 get() 函数。由于智能指针是一个对象，所以if (my_smart_object)永远为真，要判断智能指针的裸指针是否为空，需要这样判断：if (my_smart_object.get())。

智能指针包含了 reset() 方法，如果不传递参数（或者传递 NULL），则智能指针会释放当前管理的内存。如果传递一个对象，则智能指针会释放当前对象，来管理新传入的对象。

share_ptr, unique_ptr, weak_ptr

##### 12. 拷贝构造函数和赋值构造函数区别，如何不能使用赋值构造函数。如何判断一个对象是自己拷贝自己

**拷贝构造函数**

**在C++中，3种对象需要复制，此时拷贝构造函数会被调用**

**1）一个对象以值传递的方式传入函数体**

**2）一个对象以值传递的方式从函数返回**

**3）一个对象需要通过另一个对象进行初始化**

**什么时候编译器会生成默认的拷贝构造函数：**

**1）如果用户没有自定义拷贝构造函数，并且在代码中使用到了拷贝构造函数，编译器就会生成默认的拷贝构造函数。但如果用户定义了拷贝构造函数，编译器就不在生成。**

**2）如果用户定义了一个构造函数，但不是拷贝构造函数，而此时代码中又用到了拷贝构造函数，那编译器也会生成默认的拷贝构造函数。**

因为系统提供的默认拷贝构造函数工作方式是内存拷贝，也就是浅拷贝。如果对象中用到了需要手动释放的对象，则会出现问题，这时就要手动重载拷贝构造函数，实现深拷贝。

**下面说说深拷贝与浅拷贝：**

**浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用，两个对象不独立，删除空间存在）**

**深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。**

区别：

**1）拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。**

**2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象**

**3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。**

##### 13. 使用递归要注意什么，使用递归有什么好处坏处

优点：

1. 简洁

2.在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。

缺点：

1.递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。->效率

2.递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在重复计算，如fibonacci斐波那契数列的递归实现。->效率

3.调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。->性能

注意事项：

递归的要保证递归条件的正确设置，避免死循环

##### 14. C++11新特性（看网站和书）



## Linux

##### 1. linux系统下，编辑一个文件，突然断电了，文件是否有保存

在用vim打开一个文件时，其会产生一个filename.swap文件，用于保存数据，当文件非正常关闭时，可用此文件来恢复，当正常关闭时，此文件会被删除，非正常关闭时，不会被删除，所以提示存在.swap文件，此时你可以恢复文件：

vim -r filename.c

恢复以后把.swap文件删掉，在打开时就不会用提示良，注意.swap文件是个隐藏文件。可用：la查看。以.开头的是隐藏文件。

##操作系统

#####1. 进程和线程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

#####2. 死锁的必要条件，怎么处理死锁。

   （1）互斥条件：一个资源每次只能被一个进程使用

  （2）占有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放

   （3）非抢占：进程已获得的资源，在未使用完之前，不能强行剥夺

  （4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

​         处理死锁：破坏以上四个条件之一

#####3. 段存储，页存储，段页存储的区别

用户程序的逻辑地址空间被划分成若干固定大小的区域，称为“页”或者“页面”，相应地，内存物理空间也分成相对应的若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。

优点：没有外碎片，每个内碎片不超过页的大小。

缺点：程序全部装入内存，要求有相应的硬件支持。

分页存储管理的逻辑地址结构如下图所示

![img](http://upload-images.jianshu.io/upload_images/847270-04c94e7e8aa7d639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491)

分页存储逻辑地址结构.png

11位为页内地址，即每页大小为4KB；12

页表

为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。

在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见页表作用是实现从页号到物理块号的地址映射，如下图所示

![img](https://upload-images.jianshu.io/upload_images/847270-a6b9fb406c83f839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

段存储

将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。

优点：可以分别编写和编译，可以针对不同类型的段采用不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。

缺点：会产生碎片。

段页存储

作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。

段页式管理是段式管理与页式管理方案结合而成的所以具有他们两者的优点。但反过来说，由于管理软件的增加，复杂性和开销也就随之增加了

#####4. 虚拟地址、逻辑地址、物理地址

虚拟地址是由程序产生的由段选择符和段内偏移地址组成的地址。这两部分组成的地址并没有直接访问物理内存，而是要通过分段地址的变换处理后才会对应到相应的物理内存地址。

逻辑地址指由程序产生的段内偏移地址。有时把逻辑地址当成虚拟地址，两者并没有明确的界限。

线性地址是指虚拟地址到物理地址变换的中间层， 是处理器可寻址的内存空间（称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说段中的偏移地址，加上相应段基址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。

物理地址是指现在 CPU 外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。

#####5. 进程调度算法

先进先出算法（FIFO）、时间片轮转算法（RR）、最高优先级算法（HPF）、多级队列反馈法

处理作业调度算法：先来先服务调度算法（FCFS）、短作业优先调度算法（

SJF）、最高响应比优先算法（HRN）、基于优先数调度算法（HPF）

#####6. 分别从操作系统的内存角度与进程线程角度解释分析堆，栈二者的区别

操作系统内存：堆一般由程序员分配释放，若程序员不释放，内存将在程序接受由操作系统回收。栈由编译器自动分配释放，存放函数的参数值、局部变量 。

进程线程：进程拥有自己的地址空间，具有堆栈段，而线程共享进程的资源，只具有栈段。

#####7. 为什么内存快，外存慢

内存存储器直接向运算器和控制器提供（CPU）提供数据和指令，用于存放电脑当前正待运行的程序和数据 。

外存存储器作为内存储器的延伸和后院，用于存放暂时不用的程序和数据，速度慢。

#####8. 进程通信的方式,

无名管道、有名管道、流管道、消息队列、信号、信号量、socket、共享内存 

#####9. 一级缓存与二级缓存

一级缓存就是Session级别的缓存，一个Session做了一个查询操作，它会把这个操作的结果放在一级缓存中，如果短时间内这个session（一定要同一个session）又做了同一个操作，那么hibernate直接从一级缓存中拿，而不会再去连数据库，取数据；

二级缓存就是SessionFactory级别的缓存，顾名思义，就是查询的时候会把查询结果缓存到二级缓存中，如果同一个sessionFactory创建的某个session执行了相同的操作，hibernate就会从二级缓存中拿结果，而不会再去连接数据库；

#####10. 事务

事务（transaction）是由指逻辑上对数据的的一组操作， 这组操作要么一次全部成功，如果这组操作全部失败，是不可分割的一个工作单位。

ACID(原子性，一致性，隔离性，持久性)

##### 11.虚拟内存

优点：可以弥补物理内存大小的不足；一定程度的提高反映速度；减少对物理内存的读取从而保护内存延长内存使用寿命；

缺点：占用一定的物理硬盘空间；加大了对硬盘的读写；设置不得当会影响整机稳定性与速度

##### 12. 两个线程同时写一份文件会出错吗？

不同的线程是同时写一个文件会出错，所以要加锁

##### 13. I/O多路复用（看网站）

　　I/O多路复用实际上就是用select, poll, epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个socket。当然具体区别我们后面再讨论，现在先来看下I/O多路复用的流程：

![img](https://images2015.cnblogs.com/blog/986023/201705/986023-20170516211049135-1446828952.png)

　　（1）当用户进程调用了select，那么整个进程会被block；

​      （2）而同时，kernel会“监视”所有select负责的socket；

　　（3）当任何一个socket中的数据准备好了，select就会返回；

　　（4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

　　所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的**任意一个进入读就绪状态**，select()**函数就可以返回**。

　　这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。

　　所以，**如果处理的连接数不是很高的话**，使用**select/epoll的web server不一定**比使用**多线程 + 阻塞 IO**的web server性能更好，可能延迟还更大。

　　select/epoll的优势**并不是**对于单个连接能处理得**更快**，而是在于能处理**更多**的连接。）

　　在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。



##计网

#####1. OSI 与 TCP/IP 各层的结构与功能，协议和作用。

OSI共有七层：应用层、表示层、会话层、运输层、网络层、链路层、物理层

##### 2.TCP 与 UDP 的区别 

```
1、基于连接与无连接。
2、TCP要求系统资源较多，UDP较少。
3、UDP程序结构较简单。
4、流模式（TCP）与数据报模式(UDP)。
5、TCP保证数据正确性，UDP可能丢包。
6、TCP保证数据顺序，UDP不保证。
7、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
8、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
9、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。
10、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
11、TCP首部开销20字节;UDP的首部开销小，只有8个字节。
12、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。
```

#####3. TCP 报文结构。

![img](file:///C:/Users/KEYS/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

#####4. 谈谈 HTTP 中Get 和 Post 方法的区别？

1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.


2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。
4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.

##### 5.Http 的常见状态码含义

200                   服务器已成功处理了请求并提供了请求的网页。
204                   服务器成功处理了请求，但没有返回任何内容。                         
重定向3××       每次请求中使用重定向不要超过 5 次。
301                   请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。
302                   请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。
304                   如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。
客户端错误4××  表示请求可能出错，妨碍了服务器的处理。
400                    服务器不理解请求的语法。
403                    服务器拒绝请求。
404                    服务器找不到请求的网页。服务器上不存在的网页经常会返回此代码。
410                    请求的资源永久删除后，服务器返回此响应。该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时用来替代404 代码。如果资源已永久删除，应当使用 301 指定资源的新位置。
服务器错误5××   表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。
500                     服务器遇到错误，无法完成请求。
503                     服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。

#####6. ARP是哪一层协议、是干什么用的

ARP协议可以动态地在三层IP地址和二层MAC地址之间建立一种映射关系。

#####7. URL编码

 每对name/value由&；符分开；每对来自表单的name/value由=符分开

##### 8.session和cookie

1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。

session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

##### 4.HTTP1.0和HTTP1.1

```
HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent  connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).
```

##### 5. VPN在七层协议哪一层

TCP和IP

## Innodb引擎

HEAP， CSV, IASM

Innodb引擎提供了对数据库ACID（原子性，一致性，隔离性，持久性）事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

**SQL 事务隔离级别**

**概述**

​     隔离级别用于决定如果控制并发用户如何读写数据的操作，同时对性能也有一定的影响作用。

**步骤**

事务隔离级别通过影响读操作来间接地影响写操作；可以在回话级别上设置事务隔离级别也可以在查询（表级别）级别上设置事务隔离级别。
事务隔离级别总共有6个隔离级别：
READ UNCOMMITTED(未提交读,读脏),相当于(NOLOCK)
READ COMMITTED(已提交读,默认级别)
REPEATABLE READ(可以重复读),相当于(HOLDLOCK)
SERIALIZABLE(可序列化)
SNAPSHOT(快照)
READ COMMITTED SNAPSHOT(已经提交读隔离)
对于前四个隔离级别：READ UNCOMMITTED<READ COMMITTED<REPEATABLE READ<SERIALIZABLE
隔离级别越高,读操作的请求锁定就越严格,锁的持有时间久越长;所以隔离级别越高,一致性就越高,并发性就越低,同时性能也相对影响越大.

## MyIASM引擎

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

## 两种引擎的选择

大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。

##WEB安全 

HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：

1.浏览器将自己支持的一套加密规则发送给网站。
2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
3.获得网站证书之后浏览器要做以下工作：
a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
4.网站接收浏览器发来的数据之后要做以下的操作：
a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。
b) 使用密码加密一段握手消息，发送给浏览器。
5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。
这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：
非对称加密算法：RSA，DSA/DSS
对称加密算法：AES，RC4，3DES
HASH算法：MD5，SHA1，SHA256
其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。
TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息

#####1. 什么是索引？

一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构 。使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。

#####2. 什么样的数据结构可以作为索引？

**B-Tree** 是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是**有序的**。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。

#####3. 索引是怎么提升性能的？

因为索引基本上是用来存储列值的数据结构，这使查找这些列值更加快速。如果索引使用最常用的数据结构-B-Tree-那么其中的数据是有序的。有序的列值可以极大的提升性能。下面解释原因。

假设我们在 Employee_Name这一列上创建一个B-Tree索引。这意味着当我们用之前的SQL查找姓名是‘Jesus’的雇员时，不需要再扫描全表。而是用索引查找去查找名字为‘Jesus’的雇员，因为索引已经按照按字母顺序排序。索引**已经排序**意味着查询一个名字会快很多，因为名字少字母为‘J’的员工都是排列在一起的。另外重要的一点是，索引同时存储了表中相应行的指针以获取其他列的数据。

#####4. 数据库索引里究竟存的是什么？

你现在已经知道数据库索引是创建在表的某列上的，并且存储了这一列的所有值。但是，需要理解的重点是**数据库索引并不存储这个表中其他列（字段）的值**。举例来说，如果我们在Employee_Name列创建索引，那么列Employee_Age和Employee_Address上的值并不会存储在这个索引当中。如果我们确实把其他所有字段也存储在个这个索引中，那就成了拷贝一整张表做为索引-这样会占用太大的空间而且会十分低效。

#####5. 索引存储了指向表中某一行的指针

如果我们在索引里找到某一条记录作为索引的列的值，如何才能找到这一条记录的其它值呢？这是很简单 - 数据库索引同时存储了指向表中的相应行的指针。指针是指一块内存区域， 该内存区域记录的是对硬盘上记录的相应行的数据的引用。因此，索引中除了存储列的值，还存储着一个指向在行数据的索引。也就是说，索引中的Employee_Name这列的某个值（或者节点）可以描述为 (“Jesus”, 0x82829)， 0x82829 就是包含 “Jesus”那行数据在硬盘上的地址。如果没有这个引用，你就只能访问到一个单独的值（“Jesus”），而这样没有意义，因为你不能获取这一行记录的employee的其他值-例如地址（address）和年龄（age）。

##### 6.有一百万个数据，当要插入、删除一个数据时，用什么数据结构最快 

数据的插入，查找，删除操作都比较快，那就选map吧，它是基于红黑树来做的，这三个操作时间复杂度都在nlogn左右
vector和list都有自己的不足。其实，最好的应该是HashTable，可惜它不是标准STL里的东西。HashTable应该是所有的数据结构中
插入，查找，删除操作综合起来最快的

##### 7.为什么说 MD5 是不可逆的？ 

MD5不可逆的原因是其是一种散列函数，使用的是hash算法，在计算过程中原文的部分信息是丢失了的

##### 8. MD5原理

对md5算法简要的叙述可以为：md5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 

在 md5算法中，首先需要对信息进行填充，使其字节长度对512求余的结果等于448。因此，信息的字节长度（bits length）将被扩展至n*512+448，即n*64+56个字节（bytes），n为一个正整数。填充的方法如下，在信息的后面填充一个1和无数个 0，直到满足上面的条件时才停止用0对信息的填充。然后，在在这个结果后面附加一个以64位黑吧表示的填充前信息长度。经过这两步的处理，现在的信息字节长度=n*512+448+64=(n+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。 

md5中有四个32位被称作链接变量（chaining variable）的整数参数，他们分别为：a=0x01234567，b=0x89abcdef，c=0xfedcba98，d=0x76543210。 

当设置好这四个链接变量后，就开始进入算法的四轮循环运算。循环的次数是信息中512位信息分组的数目。 

##### 9.访问量过大出现500错误，如何排查（php） 

php 新手在初期搭建完开发环境后，开发时出现语法错误时，服务器返回500 （ 服务器内部错误），而不是返回错误提示。 这时候需要对开发环境做一些配置，帮助你快速查找问题原因，定位问题，解决问题。

   找到 php的配置文件  /etc/php.ini 

​    配置参数值：display_errors = On 

 error_reporting = E_ALL | E_STRICT

  重启apache 服务  service  httpd  restart 

  这个时候 浏览器已经可以输出错误信息了。

  需要再配置下 apache    /etc/httpd/conf/httpd.conf

 在 apache的配置文件最后添加 两行：

php_flag display_errors on
php_value error_reporting 2039 

重启apache。

对php.ini 中参数的设置 也可用在php代码中完成。

调用：调用ini_set()函数

//开启php.ini中的display_errors指令
ini_set('display_errors',1);

//通过error_reporting()函数设置，输出所有级别的错误报告
error_reporting(E_ALL);

这样可用动态的，在指定的php文件中，输出错误。

由于大量并发，出现 500 错误是很正常的，是因为你服务器的并发达到了上限。
这跟你设置`最大执行时间`是没有关系的
解决
0、优化运行速度，加缓存等等。
1、横向，加机器
2、纵向，提升单机的配置



## 项目性能优化

1. 设置超时
2. 数据库连表，减少数据库连接
3. 多开线程并发执行
4. 加密信息
5. 异常处理
6. 爬虫时某些关键点加上timeleep，减少timesleep的使用
7. 使用缓存

## 实习锻炼、提高最大的是什么

1. 扎实编程基础，通过对stl，HTTP请求方法，数据库等的使用，对项目开发过程中的这些技能有了更进一步的掌握，可以自主搭建项目框架，进行项目
2. 掌握了比较规范的代码编写能力，能用比较优美易懂的代码编写程序
3. 学到了一些很有用的算法，因为是做文本分析，所以对数据挖掘的一些算法有了了解，甚至掌握了一部分，比如TF-IDF算法
4. 团队项目管理经验，知道了一个项目团队要如何运营，如何去做需求分析，又如何针对这些需求制定有效的方案，都让我收获很多

##JAVA8新特性：

**2.1Lambda****表达式和函数式接口******

**2.2****接口的默认方法和静态方法**

**2.3  **重复注解annotation @

2.4 扩展注解的支持

2.5 JavaScript引擎Nashorn

## 算法

##### 1. 单词翻转

1. 遍历字符串，将整个字符串反转，在将每个单词反转（常用）
2. 将字符串切割为单词，然后压栈，弹出

##### 2. 动态规划

线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；

区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；

树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；

背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶（[同济](https://baike.baidu.com/item/%E5%90%8C%E6%B5%8E/7707206)ACM第1132题）等；

应用实例：

最短路径问题 ，项目管理，网络流优化等；

POJ动态规划题目列表：

